pragma solidity ^0.4.17;

contract MalwareDetection {
    address[] public deployedMalwares;
    address[] public deployedTestingNodes;

    function createMalware(string MalwareHash,uint minimum) public payable {
        string memory Malwarehash = MalwareHash;
        address newMalware = new Malware(Malwarehash, msg.sender,minimum,deployedTestingNodes);
        deployedMalwares.push(newMalware);

        for(uint i = 0;i<DeployedNodesLength();i++){
            TestingNode temp = TestingNode(deployedTestingNodes[i]);
            temp.addMalwares(newMalware);
        }
    }


    function DeployedMalwaresLength() public view returns (uint) {
        return deployedMalwares.length;
    }


    function createTestingNode() public {
        address newNode = new TestingNode(msg.sender,50);
        deployedTestingNodes.push(newNode);



    }

    function getDeployedNodes() public view returns (address[]) {
        return deployedTestingNodes;
    }

    function DeployedNodesLength() public view returns (uint) {
        return deployedTestingNodes.length;
    }

    function getDeployedMalwares() public view returns (address[]) {
        return deployedMalwares;
    }


    function getMyNode() public view returns(address){
       for(uint i = 0;i<DeployedNodesLength();i++){
            TestingNode temp = TestingNode(deployedTestingNodes[i]);
            if(temp.MyAddress() == msg.sender){
                return deployedTestingNodes[i];
            }
        }
    }

}

contract Malware {


    address public addedAddress;
    uint public prob;
    address public deployedUser;
    string public MalwareHash;
    uint public amount;
    address[] public allNodes;
    uint public perCentMalware;




    function Malware(string MalwareHash1,address creator,uint amountSent,address[] nodes ) public payable{
        deployedUser = creator;
        MalwareHash = MalwareHash1;
        amount = amountSent;
        perCentMalware = 0;
        allNodes = nodes;
    }

     function getSummary() public view returns (
      address,uint,address,string,uint,uint
      ) {
        return (
          addedAddress,
          prob,
          deployedUser,
          MalwareHash,
          amount,
          perCentMalware

        );
    }



    //  a consensus value will be calculated using values stored in nodes

    function consensus() public payable 		//  returns mean of all probabilities
    {
        if(allNodes.length == 0)
        {
            prob = 300;
            return;
        }
        uint den = 0;
        uint consent=0;
        //  calculation of weighted-mean
        for(uint i=0; i < allNodes.length; ++i)
        {
            TestingNode test = TestingNode(allNodes[i]);

            if(test.trustValue() <= 0){
                continue;
            }

            consent += test.trustValue()*test.perCent(this);
            den += test.trustValue();
        }

        consent /= den;

        //  trust values of nodes will be modified based on statistical heuristics

        //  update trust by standard deviation from consensus
        for(i = 0; i < allNodes.length; ++i)
        {
            TestingNode temp = TestingNode(allNodes[i]);

            uint dev;
            if(temp.perCent(this) > consent)
                dev = temp.perCent(this) - consent;
            else
                dev = consent -temp.perCent(this);
            temp.setTrust( 100 - dev );

            temp.approve(this,200); // setting it to value for busy()
        }
        prob = consent;






    }

    function getProb() public payable returns(uint)
    {
	return prob;
    }

    function getHash() public view returns(string){
        return  MalwareHash;
    }

    function getDeployedUser() public view returns(address){
        return deployedUser;
    }



}

contract TestingNode{
    address public nodeAddress;
    uint public trustValueVar;
    mapping(address => uint) public malwares;

    modifier restricted() {
        require(msg.sender == nodeAddress);
        _;
    }

    function TestingNode(address nodeA,uint trust) public payable{
        nodeAddress = nodeA;
        trustValueVar = trust;

    }

    function addMalwares(address addr) public payable{
        malwares[addr] = 0;
    }


    function trustValue() public view returns (uint) {
        return trustValueVar;
    }

    function setTrust(uint val) public payable{
        trustValueVar = val;
    }

    function perCent(address addr) public view returns (uint) {
        return malwares[addr];
    }

    function MyAddress() public view returns (address) {
        return nodeAddress;
    }


    function approve(address addr,uint val) public restricted payable{
        malwares[addr] = val;

    }

}
